# å¤šç”¨æˆ·å…±äº«è´¦å·åŠŸèƒ½æŠ€æœ¯æ–¹æ¡ˆ

## 1. éœ€æ±‚æ¦‚è¿°

### 1.1 åŠŸèƒ½éœ€æ±‚
- **å¤šç”¨æˆ·æ·»åŠ åŒåè´¦å·**ï¼šä¸åŒç”¨æˆ·å¯ä»¥æ·»åŠ ç›¸åŒè´¦å·åçš„æ¸¸æˆè´¦å·
- **è´¦å·ç»Ÿä¸€ç®¡ç†**ï¼šç›¸åŒè´¦å·åè¢«è§†ä¸ºåŒä¸€ä¸ªé€»è¾‘è´¦å·
- **å…±äº«è¿›åº¦æ›´æ–°**ï¼šæ‰€æœ‰å…³è”ç”¨æˆ·éƒ½å¯ä»¥æ›´æ–°è¯¥è´¦å·çš„æ¸¸æˆè¿›åº¦
- **æƒé™æ§åˆ¶**ï¼šåˆç†çš„æƒé™ç®¡ç†æœºåˆ¶ï¼Œç¡®ä¿æ•°æ®å®‰å…¨

### 1.2 æŠ€æœ¯çº¦æŸ
- åŸºäºç°æœ‰ NestJS + TypeORM æ¶æ„
- ä¿æŒå‘åå…¼å®¹æ€§
- ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
- æ”¯æŒå¹³æ»‘è¿ç§»

## 2. å½“å‰æ¶æ„åˆ†æ

### 2.1 ç°æœ‰æ•°æ®æ¨¡å‹é—®é¢˜
```typescript
// å½“å‰Accountå®ä½“çš„é™åˆ¶
@Entity('accounts')
export class Account {
  @PrimaryColumn()
  accountId: string;        // æ¯ä¸ªè´¦å·ç‹¬ç«‹ID
  
  @Column()
  userId: string;           // ä¸¥æ ¼ç»‘å®šåˆ°å•ä¸€ç”¨æˆ·
  
  @Column()
  name: string;             // è´¦å·åå¯é‡å¤ä½†éš”ç¦»
}
```

**é—®é¢˜è¯†åˆ«**ï¼š
- ä¸¥æ ¼çš„ç”¨æˆ·éš”ç¦»ï¼š`account.userId !== userId` æ—¶æŠ›å‡ºæƒé™å¼‚å¸¸
- æ— æ³•å®ç°è´¦å·å…±äº«ï¼šæ¯ä¸ªè´¦å·åªå±äºä¸€ä¸ªç”¨æˆ·
- è¿›åº¦æ•°æ®å­¤ç«‹ï¼šç›¸åŒè´¦å·åçš„è¿›åº¦æ— æ³•åˆå¹¶

### 2.2 æƒé™éªŒè¯é™åˆ¶
```typescript
// å½“å‰æƒé™éªŒè¯é€»è¾‘çš„é—®é¢˜
private async validateAccountAccess(accountId: string, userId: string) {
  // ğŸš¨ ä¸¥æ ¼çš„å•ç”¨æˆ·æƒé™æ£€æŸ¥
  if (account.userId !== userId) {
    throw new ForbiddenException('æ— æƒè®¿é—®æ­¤è´¦å·');
  }
}
```

## 3. æ•°æ®åº“æ¶æ„è°ƒæ•´æ–¹æ¡ˆ

### 3.1 æ–°å¢å…±äº«è´¦å·å®ä½“

```sql
-- åˆ›å»ºå…±äº«è´¦å·ä¸»è¡¨
CREATE TABLE shared_accounts (
    account_name VARCHAR(50) PRIMARY KEY,
    display_name VARCHAR(100),
    server_name VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_server_name (server_name),
    INDEX idx_is_active (is_active)
);

-- åˆ›å»ºç”¨æˆ·è´¦å·å…³è”è¡¨
CREATE TABLE user_account_relations (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    account_name VARCHAR(50) NOT NULL,
    relation_type ENUM('owner', 'contributor') DEFAULT 'contributor',
    permissions JSON DEFAULT '{"read": true, "write": true}',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(userId) ON DELETE CASCADE,
    FOREIGN KEY (account_name) REFERENCES shared_accounts(account_name) ON DELETE CASCADE,
    UNIQUE KEY unique_user_account (user_id, account_name),
    INDEX idx_user_id (user_id),
    INDEX idx_account_name (account_name)
);
```

### 3.2 TypeORM å®ä½“å®šä¹‰

```typescript
// å…±äº«è´¦å·å®ä½“
@Entity('shared_accounts')
export class SharedAccount {
  @PrimaryColumn({ type: 'varchar', length: 50 })
  accountName: string;

  @Column({ type: 'varchar', length: 100, nullable: true })
  displayName: string;

  @Column({ type: 'varchar', length: 50, nullable: true })
  serverName: string;

  @Column({ type: 'boolean', default: true })
  @Index()
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // å…³è”å…³ç³»
  @OneToMany(() => UserAccountRelation, relation => relation.sharedAccount)
  userRelations: UserAccountRelation[];

  @OneToMany(() => WeeklyProgress, progress => progress.sharedAccount)
  weeklyProgresses: WeeklyProgress[];
}

// ç”¨æˆ·è´¦å·å…³è”å®ä½“
@Entity('user_account_relations')
export class UserAccountRelation {
  @PrimaryColumn({ type: 'varchar', length: 36 })
  id: string;

  @BeforeInsert()
  generateId() {
    if (!this.id) {
      this.id = uuidv4();
    }
  }

  @Column({ type: 'varchar', length: 36 })
  @Index()
  userId: string;

  @Column({ type: 'varchar', length: 50 })
  @Index()
  accountName: string;

  @Column({ 
    type: 'enum', 
    enum: ['owner', 'contributor'], 
    default: 'contributor' 
  })
  relationType: 'owner' | 'contributor';

  @Column({ 
    type: 'json', 
    default: () => "'{}'" 
  })
  permissions: {
    read: boolean;
    write: boolean;
    delete?: boolean;
  };

  @CreateDateColumn()
  joinedAt: Date;

  // å…³è”å…³ç³»
  @ManyToOne(() => User, user => user.accountRelations, {
    onDelete: 'CASCADE'
  })
  @JoinColumn({ name: 'userId' })
  user: User;

  @ManyToOne(() => SharedAccount, account => account.userRelations, {
    onDelete: 'CASCADE'
  })
  @JoinColumn({ name: 'accountName' })
  sharedAccount: SharedAccount;
}
```

### 3.3 æ›´æ–°è¿›åº¦å®ä½“

```typescript
// æ›´æ–°WeeklyProgresså®ä½“ä»¥æ”¯æŒå…±äº«è´¦å·
@Entity('weekly_progress')
export class WeeklyProgress {
  @PrimaryColumn({ type: 'varchar', length: 36 })
  progressId: string;

  // ä¿ç•™åŸæœ‰å­—æ®µä»¥æ”¯æŒå‘åå…¼å®¹
  @Column({ type: 'varchar', length: 36, nullable: true })
  @Index()
  accountId: string;

  // æ–°å¢å…±äº«è´¦å·å…³è”
  @Column({ type: 'varchar', length: 50, nullable: true })
  @Index()
  sharedAccountName: string;

  @Column({ type: 'datetime' })
  @Index()
  weekStart: Date;

  @Column({ type: 'json', default: () => "'{}'" })
  dungeonProgress: Record<string, boolean>;

  @Column({ type: 'json', default: () => "'{}'" })
  weeklyTaskProgress: Record<string, number>;

  @UpdateDateColumn()
  lastUpdated: Date;

  // å…³è”å…³ç³»
  @ManyToOne(() => Account, account => account.weeklyProgresses, {
    onDelete: 'CASCADE',
    nullable: true
  })
  @JoinColumn({ name: 'accountId' })
  account: Account;

  @ManyToOne(() => SharedAccount, sharedAccount => sharedAccount.weeklyProgresses, {
    onDelete: 'CASCADE',
    nullable: true
  })
  @JoinColumn({ name: 'sharedAccountName' })
  sharedAccount: SharedAccount;
}
```

## 4. APIæ¥å£è®¾è®¡å˜æ›´

### 4.1 å…±äº«è´¦å·ç®¡ç†æ¥å£

```typescript
@ApiTags('å…±äº«è´¦å·ç®¡ç†')
@ApiBearerAuth()
@UseGuards(JwtAuthGuard)
@Controller('shared-accounts')
export class SharedAccountsController {
  
  @Post()
  @ApiOperation({ summary: 'åˆ›å»ºæˆ–åŠ å…¥å…±äº«è´¦å·' })
  async createOrJoinAccount(
    @Body() dto: CreateSharedAccountDto,
    @Request() req: AuthenticatedRequest
  ) {
    return this.sharedAccountsService.createOrJoinAccount(
      req.user.userId, 
      dto
    );
  }

  @Get()
  @ApiOperation({ summary: 'è·å–ç”¨æˆ·å…³è”çš„æ‰€æœ‰å…±äº«è´¦å·' })
  async getUserSharedAccounts(
    @Request() req: AuthenticatedRequest,
    @Query() query: SharedAccountListDto
  ) {
    return this.sharedAccountsService.getUserSharedAccounts(
      req.user.userId, 
      query
    );
  }

  @Get(':accountName/contributors')
  @ApiOperation({ summary: 'è·å–è´¦å·çš„æ‰€æœ‰è´¡çŒ®è€…' })
  async getAccountContributors(
    @Param('accountName') accountName: string,
    @Request() req: AuthenticatedRequest
  ) {
    return this.sharedAccountsService.getAccountContributors(
      accountName, 
      req.user.userId
    );
  }

  @Patch(':accountName/permissions')
  @ApiOperation({ summary: 'æ›´æ–°ç”¨æˆ·æƒé™ï¼ˆä»…è´¦å·æ‰€æœ‰è€…ï¼‰' })
  async updateUserPermissions(
    @Param('accountName') accountName: string,
    @Body() dto: UpdatePermissionsDto,
    @Request() req: AuthenticatedRequest
  ) {
    return this.sharedAccountsService.updateUserPermissions(
      accountName,
      req.user.userId,
      dto
    );
  }
}
```

### 4.2 DTO å®šä¹‰

```typescript
// åˆ›å»ºå…±äº«è´¦å·DTO
export class CreateSharedAccountDto {
  @IsString()
  @Length(1, 50)
  @ApiProperty({ description: 'è´¦å·åç§°' })
  accountName: string;

  @IsOptional()
  @IsString()
  @Length(1, 100)
  @ApiProperty({ description: 'æ˜¾ç¤ºåç§°', required: false })
  displayName?: string;

  @IsOptional()
  @IsString()
  @Length(1, 50)
  @ApiProperty({ description: 'æœåŠ¡å™¨åç§°', required: false })
  serverName?: string;

  @IsOptional()
  @IsBoolean()
  @ApiProperty({ description: 'æ˜¯å¦æ¿€æ´»', default: true })
  isActive?: boolean;
}

// æƒé™æ›´æ–°DTO
export class UpdatePermissionsDto {
  @IsString()
  @ApiProperty({ description: 'ç›®æ ‡ç”¨æˆ·ID' })
  targetUserId: string;

  @IsObject()
  @ApiProperty({ description: 'æƒé™é…ç½®' })
  permissions: {
    read: boolean;
    write: boolean;
    delete?: boolean;
  };

  @IsOptional()
  @IsEnum(['owner', 'contributor'])
  @ApiProperty({ description: 'å…³ç³»ç±»å‹' })
  relationType?: 'owner' | 'contributor';
}
```

## 5. æƒé™éªŒè¯é€»è¾‘é‡æ„

### 5.1 æ–°çš„æƒé™éªŒè¯æœåŠ¡

```typescript
@Injectable()
export class SharedAccountPermissionService {
  constructor(
    @InjectRepository(UserAccountRelation)
    private relationRepository: Repository<UserAccountRelation>,
    @InjectRepository(SharedAccount)
    private sharedAccountRepository: Repository<SharedAccount>
  ) {}

  /**
   * éªŒè¯ç”¨æˆ·å¯¹å…±äº«è´¦å·çš„è®¿é—®æƒé™
   */
  async validateSharedAccountAccess(
    accountName: string,
    userId: string,
    requiredPermission: 'read' | 'write' | 'delete' = 'read'
  ): Promise<UserAccountRelation> {
    const relation = await this.relationRepository.findOne({
      where: { accountName, userId },
      relations: ['sharedAccount', 'user']
    });

    if (!relation) {
      throw new ForbiddenException('æ— æƒè®¿é—®æ­¤å…±äº«è´¦å·');
    }

    if (!relation.sharedAccount.isActive) {
      throw new BadRequestException('è´¦å·å·²è¢«ç¦ç”¨');
    }

    // æ£€æŸ¥å…·ä½“æƒé™
    if (!this.hasPermission(relation, requiredPermission)) {
      throw new ForbiddenException(`ç¼ºå°‘${requiredPermission}æƒé™`);
    }

    return relation;
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ç‰¹å®šæƒé™
   */
  private hasPermission(
    relation: UserAccountRelation, 
    permission: 'read' | 'write' | 'delete'
  ): boolean {
    // æ‰€æœ‰è€…æ‹¥æœ‰æ‰€æœ‰æƒé™
    if (relation.relationType === 'owner') {
      return true;
    }

    // æ£€æŸ¥å…·ä½“æƒé™é…ç½®
    return relation.permissions[permission] === true;
  }

  /**
   * è·å–ç”¨æˆ·åœ¨è´¦å·ä¸­çš„è§’è‰²
   */
  async getUserRole(accountName: string, userId: string): Promise<string | null> {
    const relation = await this.relationRepository.findOne({
      where: { accountName, userId }
    });

    return relation?.relationType || null;
  }
}
```

### 5.2 è¿›åº¦æœåŠ¡æƒé™é›†æˆ

```typescript
@Injectable()
export class ProgressService {
  constructor(
    @InjectRepository(WeeklyProgress)
    private progressRepository: Repository<WeeklyProgress>,
    @InjectRepository(SharedAccount)
    private sharedAccountRepository: Repository<SharedAccount>,
    private permissionService: SharedAccountPermissionService
  ) {}

  /**
   * æ›´æ–°å…±äº«è´¦å·çš„å‰¯æœ¬è¿›åº¦
   */
  async updateSharedAccountDungeonProgress(
    dto: UpdateSharedDungeonProgressDto,
    userId: string
  ): Promise<WeeklyProgress> {
    const { accountName, dungeonName, bossName, killCount } = dto;

    // éªŒè¯å†™æƒé™
    await this.permissionService.validateSharedAccountAccess(
      accountName, 
      userId, 
      'write'
    );

    const weekStart = this.getCurrentWeekStart();
    let progress = await this.progressRepository.findOne({
      where: { sharedAccountName: accountName, weekStart }
    });

    if (!progress) {
      progress = this.progressRepository.create({
        progressId: uuidv4(),
        sharedAccountName: accountName,
        weekStart,
        dungeonProgress: {},
        weeklyTaskProgress: {}
      });
    }

    // æ›´æ–°è¿›åº¦æ•°æ®
    const progressKey = `${dungeonName}_${bossName}`;
    progress.dungeonProgress[progressKey] = killCount > 0;
    progress.lastUpdated = new Date();

    return this.progressRepository.save(progress);
  }

  /**
   * è·å–å…±äº«è´¦å·çš„å½“å‰å‘¨è¿›åº¦
   */
  async getSharedAccountProgress(
    accountName: string,
    userId: string
  ): Promise<WeeklyProgress> {
    // éªŒè¯è¯»æƒé™
    await this.permissionService.validateSharedAccountAccess(
      accountName, 
      userId, 
      'read'
    );

    const weekStart = this.getCurrentWeekStart();
    let progress = await this.progressRepository.findOne({
      where: { sharedAccountName: accountName, weekStart },
      relations: ['sharedAccount']
    });

    if (!progress) {
      // åˆ›å»ºç©ºè¿›åº¦è®°å½•
      progress = this.progressRepository.create({
        progressId: uuidv4(),
        sharedAccountName: accountName,
        weekStart,
        dungeonProgress: {},
        weeklyTaskProgress: {}
      });
    }

    return progress;
  }
}
```

## 6. æ•°æ®è¿ç§»ç­–ç•¥

### 6.1 è¿ç§»è„šæœ¬è®¾è®¡

```sql
-- ç¬¬ä¸€é˜¶æ®µï¼šåˆ›å»ºæ–°è¡¨ç»“æ„
-- 1. åˆ›å»ºå…±äº«è´¦å·è¡¨
CREATE TABLE shared_accounts (
    account_name VARCHAR(50) PRIMARY KEY,
    display_name VARCHAR(100),
    server_name VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 2. åˆ›å»ºç”¨æˆ·è´¦å·å…³è”è¡¨
CREATE TABLE user_account_relations (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    account_name VARCHAR(50) NOT NULL,
    relation_type ENUM('owner', 'contributor') DEFAULT 'owner',
    permissions JSON DEFAULT '{"read": true, "write": true, "delete": true}',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(userId) ON DELETE CASCADE,
    FOREIGN KEY (account_name) REFERENCES shared_accounts(account_name) ON DELETE CASCADE,
    UNIQUE KEY unique_user_account (user_id, account_name)
);

-- ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®è¿ç§»
-- 1. è¿ç§»ç°æœ‰è´¦å·åˆ°å…±äº«è´¦å·è¡¨
INSERT INTO shared_accounts (account_name, display_name, is_active, created_at, updated_at)
SELECT 
    name as account_name,
    name as display_name,
    isActive as is_active,
    createdAt as created_at,
    updatedAt as updated_at
FROM accounts
GROUP BY name;

-- 2. åˆ›å»ºç”¨æˆ·è´¦å·å…³è”å…³ç³»
INSERT INTO user_account_relations (id, user_id, account_name, relation_type, permissions, joined_at)
SELECT 
    UUID() as id,
    userId as user_id,
    name as account_name,
    'owner' as relation_type,
    '{"read": true, "write": true, "delete": true}' as permissions,
    createdAt as joined_at
FROM accounts;

-- ç¬¬ä¸‰é˜¶æ®µï¼šæ›´æ–°è¿›åº¦è¡¨
-- æ·»åŠ æ–°å­—æ®µ
ALTER TABLE weekly_progress 
ADD COLUMN shared_account_name VARCHAR(50) NULL,
ADD INDEX idx_shared_account_name (shared_account_name);

-- è¿ç§»è¿›åº¦æ•°æ®
UPDATE weekly_progress wp
JOIN accounts a ON wp.accountId = a.accountId
SET wp.shared_account_name = a.name;

-- æ·»åŠ å¤–é”®çº¦æŸ
ALTER TABLE weekly_progress 
ADD CONSTRAINT fk_weekly_progress_shared_account 
FOREIGN KEY (shared_account_name) REFERENCES shared_accounts(account_name) ON DELETE CASCADE;
```

### 6.2 TypeORM è¿ç§»æ–‡ä»¶

```typescript
import { MigrationInterface, QueryRunner, Table, Index, ForeignKey } from 'typeorm';

export class AddSharedAccountSupport1703001234567 implements MigrationInterface {
  name = 'AddSharedAccountSupport1703001234567';

  public async up(queryRunner: QueryRunner): Promise<void> {
    // åˆ›å»ºå…±äº«è´¦å·è¡¨
    await queryRunner.createTable(
      new Table({
        name: 'shared_accounts',
        columns: [
          {
            name: 'account_name',
            type: 'varchar',
            length: '50',
            isPrimary: true,
          },
          {
            name: 'display_name',
            type: 'varchar',
            length: '100',
            isNullable: true,
          },
          {
            name: 'server_name',
            type: 'varchar',
            length: '50',
            isNullable: true,
          },
          {
            name: 'is_active',
            type: 'boolean',
            default: true,
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
          },
        ],
        indices: [
          new Index('idx_shared_accounts_is_active', ['is_active']),
          new Index('idx_shared_accounts_server_name', ['server_name']),
        ],
      }),
      true
    );

    // åˆ›å»ºç”¨æˆ·è´¦å·å…³è”è¡¨
    await queryRunner.createTable(
      new Table({
        name: 'user_account_relations',
        columns: [
          {
            name: 'id',
            type: 'varchar',
            length: '36',
            isPrimary: true,
          },
          {
            name: 'user_id',
            type: 'varchar',
            length: '36',
          },
          {
            name: 'account_name',
            type: 'varchar',
            length: '50',
          },
          {
            name: 'relation_type',
            type: 'enum',
            enum: ['owner', 'contributor'],
            default: "'contributor'",
          },
          {
            name: 'permissions',
            type: 'json',
            default: "'{}'",
          },
          {
            name: 'joined_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
        ],
        indices: [
          new Index('idx_user_account_relations_user_id', ['user_id']),
          new Index('idx_user_account_relations_account_name', ['account_name']),
          new Index('unique_user_account', ['user_id', 'account_name'], { isUnique: true }),
        ],
        foreignKeys: [
          new ForeignKey({
            columnNames: ['user_id'],
            referencedTableName: 'users',
            referencedColumnNames: ['userId'],
            onDelete: 'CASCADE',
          }),
          new ForeignKey({
            columnNames: ['account_name'],
            referencedTableName: 'shared_accounts',
            referencedColumnNames: ['account_name'],
            onDelete: 'CASCADE',
          }),
        ],
      }),
      true
    );

    // æ•°æ®è¿ç§»é€»è¾‘
    await this.migrateExistingData(queryRunner);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('user_account_relations');
    await queryRunner.dropTable('shared_accounts');
    await queryRunner.dropColumn('weekly_progress', 'shared_account_name');
  }

  private async migrateExistingData(queryRunner: QueryRunner): Promise<void> {
    // è¿ç§»ç°æœ‰è´¦å·æ•°æ®
    await queryRunner.query(`
      INSERT INTO shared_accounts (account_name, display_name, is_active, created_at, updated_at)
      SELECT 
        name as account_name,
        name as display_name,
        isActive as is_active,
        createdAt as created_at,
        updatedAt as updated_at
      FROM accounts
      GROUP BY name
    `);

    // åˆ›å»ºç”¨æˆ·å…³è”å…³ç³»
    await queryRunner.query(`
      INSERT INTO user_account_relations (id, user_id, account_name, relation_type, permissions, joined_at)
      SELECT 
        UUID() as id,
        userId as user_id,
        name as account_name,
        'owner' as relation_type,
        '{"read": true, "write": true, "delete": true}' as permissions,
        createdAt as joined_at
      FROM accounts
    `);

    // æ›´æ–°è¿›åº¦è¡¨
    await queryRunner.addColumn('weekly_progress', new TableColumn({
      name: 'shared_account_name',
      type: 'varchar',
      length: '50',
      isNullable: true,
    }));

    await queryRunner.createIndex('weekly_progress', new Index('idx_weekly_progress_shared_account_name', ['shared_account_name']));

    await queryRunner.query(`
      UPDATE weekly_progress wp
      JOIN accounts a ON wp.accountId = a.accountId
      SET wp.shared_account_name = a.name
    `);
  }
}
```

## 7. æµ‹è¯•éªŒè¯æ–¹æ¡ˆ

### 7.1 å•å…ƒæµ‹è¯•

```typescript
describe('SharedAccountsService', () => {
  let service: SharedAccountsService;
  let permissionService: SharedAccountPermissionService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        SharedAccountsService,
        SharedAccountPermissionService,
        // Mock repositories
      ],
    }).compile();

    service = module.get<SharedAccountsService>(SharedAccountsService);
    permissionService = module.get<SharedAccountPermissionService>(SharedAccountPermissionService);
  });

  describe('createOrJoinAccount', () => {
    it('åº”è¯¥åˆ›å»ºæ–°çš„å…±äº«è´¦å·', async () => {
      const dto = {
        accountName: 'TestAccount',
        displayName: 'æµ‹è¯•è´¦å·',
        serverName: 'æµ‹è¯•æœåŠ¡å™¨'
      };

      const result = await service.createOrJoinAccount('user-1', dto);

      expect(result.accountName).toBe('TestAccount');
      expect(result.userRelations).toHaveLength(1);
      expect(result.userRelations[0].relationType).toBe('owner');
    });

    it('åº”è¯¥åŠ å…¥å·²å­˜åœ¨çš„å…±äº«è´¦å·', async () => {
      // é¢„å…ˆåˆ›å»ºè´¦å·
      await service.createOrJoinAccount('user-1', {
        accountName: 'ExistingAccount'
      });

      // ç¬¬äºŒä¸ªç”¨æˆ·åŠ å…¥
      const result = await service.createOrJoinAccount('user-2', {
        accountName: 'ExistingAccount'
      });

      expect(result.userRelations).toHaveLength(2);
    });
  });

  describe('æƒé™éªŒè¯', () => {
    it('åº”è¯¥å…è®¸æœ‰å†™æƒé™çš„ç”¨æˆ·æ›´æ–°è¿›åº¦', async () => {
      await expect(
        permissionService.validateSharedAccountAccess('TestAccount', 'user-1', 'write')
      ).resolves.not.toThrow();
    });

    it('åº”è¯¥æ‹’ç»æ— æƒé™ç”¨æˆ·çš„è®¿é—®', async () => {
      await expect(
        permissionService.validateSharedAccountAccess('TestAccount', 'unauthorized-user', 'read')
      ).rejects.toThrow(ForbiddenException);
    });
  });
});
```

### 7.2 é›†æˆæµ‹è¯•

```typescript
describe('SharedAccount Integration Tests', () => {
  let app: INestApplication;
  let authToken1: string;
  let authToken2: string;

  beforeAll(async () => {
    // åˆå§‹åŒ–æµ‹è¯•åº”ç”¨
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // åˆ›å»ºæµ‹è¯•ç”¨æˆ·å¹¶è·å–token
    authToken1 = await createTestUserAndGetToken(app, 'user1@test.com');
    authToken2 = await createTestUserAndGetToken(app, 'user2@test.com');
  });

  it('å¤šç”¨æˆ·å…±äº«è´¦å·æµç¨‹æµ‹è¯•', async () => {
    // 1. ç”¨æˆ·1åˆ›å»ºå…±äº«è´¦å·
    const createResponse = await request(app.getHttpServer())
      .post('/api/shared-accounts')
      .set('Authorization', `Bearer ${authToken1}`)
      .send({
        accountName: 'SharedTestAccount',
        displayName: 'å…±äº«æµ‹è¯•è´¦å·',
        serverName: 'æµ‹è¯•æœåŠ¡å™¨'
      })
      .expect(201);

    expect(createResponse.body.data.accountName).toBe('SharedTestAccount');

    // 2. ç”¨æˆ·2åŠ å…¥ç›¸åŒè´¦å·
    const joinResponse = await request(app.getHttpServer())
      .post('/api/shared-accounts')
      .set('Authorization', `Bearer ${authToken2}`)
      .send({
        accountName: 'SharedTestAccount'
      })
      .expect(201);

    // 3. éªŒè¯ä¸¤ä¸ªç”¨æˆ·éƒ½èƒ½çœ‹åˆ°è¯¥è´¦å·
    const user1Accounts = await request(app.getHttpServer())
      .get('/api/shared-accounts')
      .set('Authorization', `Bearer ${authToken1}`)
      .expect(200);

    const user2Accounts = await request(app.getHttpServer())
      .get('/api/shared-accounts')
      .set('Authorization', `Bearer ${authToken2}`)
      .expect(200);

    expect(user1Accounts.body.data).toContainEqual(
      expect.objectContaining({ accountName: 'SharedTestAccount' })
    );
    expect(user2Accounts.body.data).toContainEqual(
      expect.objectContaining({ accountName: 'SharedTestAccount' })
    );

    // 4. ç”¨æˆ·1æ›´æ–°è¿›åº¦
    await request(app.getHttpServer())
      .post('/api/progress/shared-dungeon')
      .set('Authorization', `Bearer ${authToken1}`)
      .send({
        accountName: 'SharedTestAccount',
        dungeonName: 'æµ‹è¯•å‰¯æœ¬',
        bossName: 'æµ‹è¯•Boss',
        killCount: 1
      })
      .expect(200);

    // 5. ç”¨æˆ·2æŸ¥çœ‹è¿›åº¦æ›´æ–°
    const progressResponse = await request(app.getHttpServer())
      .get('/api/progress/shared-account/SharedTestAccount')
      .set('Authorization', `Bearer ${authToken2}`)
      .expect(200);

    expect(progressResponse.body.data.dungeonProgress).toHaveProperty('æµ‹è¯•å‰¯æœ¬_æµ‹è¯•Boss', true);

    // 6. ç”¨æˆ·2ä¹Ÿèƒ½æ›´æ–°è¿›åº¦
    await request(app.getHttpServer())
      .post('/api/progress/shared-weekly-task')
      .set('Authorization', `Bearer ${authToken2}`)
      .send({
        accountName: 'SharedTestAccount',
        taskName: 'æµ‹è¯•ä»»åŠ¡',
        completedCount: 5
      })
      .expect(200);

    // 7. éªŒè¯è¿›åº¦åŒæ­¥
    const finalProgress = await request(app.getHttpServer())
      .get('/api/progress/shared-account/SharedTestAccount')
      .set('Authorization', `Bearer ${authToken1}`)
      .expect(200);

    expect(finalProgress.body.data.weeklyTaskProgress).toHaveProperty('æµ‹è¯•ä»»åŠ¡', 5);
  });
});
```

### 7.3 æ€§èƒ½æµ‹è¯•

```typescript
describe('SharedAccount Performance Tests', () => {
  it('åº”è¯¥èƒ½å¤„ç†å¤§é‡å¹¶å‘çš„è¿›åº¦æ›´æ–°', async () => {
    const accountName = 'HighConcurrencyAccount';
    const userCount = 50;
    const updateCount = 100;

    // åˆ›å»ºå¤šä¸ªç”¨æˆ·å¹¶åŠ å…¥åŒä¸€è´¦å·
    const users = await Promise.all(
      Array.from({ length: userCount }, (_, i) => 
        createTestUserAndJoinAccount(app, `user${i}@test.com`, accountName)
      )
    );

    // å¹¶å‘æ›´æ–°è¿›åº¦
    const startTime = Date.now();
    
    const updatePromises = users.flatMap(user => 
      Array.from({ length: updateCount }, (_, i) => 
        updateAccountProgress(user.token, accountName, `dungeon${i}`, `boss${i}`)
      )
    );

    await Promise.all(updatePromises);
    
    const endTime = Date.now();
    const duration = endTime - startTime;

    // éªŒè¯æ€§èƒ½æŒ‡æ ‡
    expect(duration).toBeLessThan(10000); // 10ç§’å†…å®Œæˆ
    
    // éªŒè¯æ•°æ®ä¸€è‡´æ€§
    const finalProgress = await getAccountProgress(users[0].token, accountName);
    expect(Object.keys(finalProgress.dungeonProgress)).toHaveLength(updateCount);
  });
});
```

## 8. å®æ–½è®¡åˆ’

### 8.1 å¼€å‘é˜¶æ®µ

| é˜¶æ®µ | ä»»åŠ¡ | é¢„ä¼°æ—¶é—´ | ä¾èµ– |
|------|------|----------|------|
| **é˜¶æ®µ1** | æ•°æ®åº“æ¶æ„è®¾è®¡ä¸è¿ç§»è„šæœ¬ | 3å¤© | - |
| **é˜¶æ®µ2** | æ–°å®ä½“å’ŒæœåŠ¡å±‚å¼€å‘ | 5å¤© | é˜¶æ®µ1 |
| **é˜¶æ®µ3** | APIæ¥å£å¼€å‘ä¸æƒé™é›†æˆ | 4å¤© | é˜¶æ®µ2 |
| **é˜¶æ®µ4** | æ•°æ®è¿ç§»æ‰§è¡Œä¸éªŒè¯ | 2å¤© | é˜¶æ®µ3 |
| **é˜¶æ®µ5** | æµ‹è¯•ç”¨ä¾‹ç¼–å†™ä¸æ‰§è¡Œ | 3å¤© | é˜¶æ®µ4 |
| **é˜¶æ®µ6** | æ–‡æ¡£æ›´æ–°ä¸éƒ¨ç½² | 2å¤© | é˜¶æ®µ5 |

### 8.2 é£é™©æ§åˆ¶

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|------|------|----------|
| **æ•°æ®è¿ç§»å¤±è´¥** | é«˜ | å®Œæ•´å¤‡ä»½ã€åˆ†æ­¥è¿ç§»ã€å›æ»šæ–¹æ¡ˆ |
| **æ€§èƒ½ä¸‹é™** | ä¸­ | ç´¢å¼•ä¼˜åŒ–ã€æŸ¥è¯¢ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥ |
| **æƒé™æ··ä¹±** | é«˜ | è¯¦ç»†æµ‹è¯•ã€æƒé™çŸ©é˜µéªŒè¯ |
| **å‘åå…¼å®¹æ€§** | ä¸­ | ä¿ç•™åŸæœ‰APIã€æ¸è¿›å¼è¿ç§» |

### 8.3 éƒ¨ç½²ç­–ç•¥

1. **ç°åº¦å‘å¸ƒ**ï¼šå…ˆåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯å®Œæ•´åŠŸèƒ½
2. **æ•°æ®å¤‡ä»½**ï¼šæ‰§è¡Œè¿ç§»å‰å®Œæ•´å¤‡ä»½æ•°æ®åº“
3. **åˆ†æ­¥éƒ¨ç½²**ï¼š
   - ç¬¬ä¸€æ­¥ï¼šéƒ¨ç½²æ–°è¡¨ç»“æ„ï¼ˆä¸å½±å“ç°æœ‰åŠŸèƒ½ï¼‰
   - ç¬¬äºŒæ­¥ï¼šæ‰§è¡Œæ•°æ®è¿ç§»
   - ç¬¬ä¸‰æ­¥ï¼šå¯ç”¨æ–°åŠŸèƒ½
   - ç¬¬å››æ­¥ï¼šé€æ­¥è¿ç§»ç”¨æˆ·åˆ°æ–°æ¨¡å¼

## 9. ç›‘æ§ä¸ç»´æŠ¤

### 9.1 å…³é”®æŒ‡æ ‡ç›‘æ§

- **å…±äº«è´¦å·æ•°é‡**ï¼šç›‘æ§å…±äº«è´¦å·çš„åˆ›å»ºå’Œä½¿ç”¨æƒ…å†µ
- **æƒé™éªŒè¯æ€§èƒ½**ï¼šç›‘æ§æƒé™æ£€æŸ¥çš„å“åº”æ—¶é—´
- **æ•°æ®ä¸€è‡´æ€§**ï¼šå®šæœŸæ£€æŸ¥è¿›åº¦æ•°æ®çš„ä¸€è‡´æ€§
- **ç”¨æˆ·æ´»è·ƒåº¦**ï¼šç›‘æ§å¤šç”¨æˆ·åä½œçš„æ´»è·ƒç¨‹åº¦

### 9.2 æ—¥å¿—è®°å½•

```typescript
// å…³é”®æ“ä½œæ—¥å¿—è®°å½•
@Injectable()
export class SharedAccountAuditService {
  async logAccountAccess(
    userId: string, 
    accountName: string, 
    action: string, 
    result: 'success' | 'failed'
  ) {
    await this.auditRepository.save({
      userId,
      accountName,
      action,
      result,
      timestamp: new Date(),
      ip: this.request.ip,
      userAgent: this.request.headers['user-agent']
    });
  }
}
```

## 10. æ€»ç»“

æœ¬æŠ€æœ¯æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„å¤šç”¨æˆ·å…±äº«è´¦å·åŠŸèƒ½å®ç°è·¯å¾„ï¼ŒåŒ…æ‹¬ï¼š

âœ… **å®Œæ•´çš„æ•°æ®åº“æ¶æ„è°ƒæ•´**ï¼šæ”¯æŒè´¦å·å…±äº«å’Œæƒé™ç®¡ç†
âœ… **çµæ´»çš„æƒé™æ§åˆ¶æœºåˆ¶**ï¼šç»†ç²’åº¦çš„æƒé™ç®¡ç†
âœ… **å‘åå…¼å®¹çš„è¿ç§»ç­–ç•¥**ï¼šå¹³æ»‘è¿‡æ¸¡ç°æœ‰æ•°æ®
âœ… **å…¨é¢çš„æµ‹è¯•éªŒè¯æ–¹æ¡ˆ**ï¼šç¡®ä¿åŠŸèƒ½ç¨³å®šæ€§
âœ… **è¯¦ç»†çš„å®æ–½è®¡åˆ’**ï¼šå¯æ“ä½œçš„å¼€å‘è·¯å¾„

é€šè¿‡å®æ–½æ­¤æ–¹æ¡ˆï¼Œç³»ç»Ÿå°†èƒ½å¤Ÿæ”¯æŒå¤šç”¨æˆ·åä½œç®¡ç†æ¸¸æˆè´¦å·è¿›åº¦ï¼Œæå‡ç”¨æˆ·ä½“éªŒå’Œæ•°æ®å…±äº«æ•ˆç‡ã€‚